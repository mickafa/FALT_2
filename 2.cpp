#include <bits/stdc++.h>
using namespace std ;
#define Me (5.9726e24)      /// масса Земли    /// индекс е = Earth
#define Re (6378100.0)      /// экваториальный радиус
#define Mm (7.3477e22)      /// масса Луны      /// индекс m = Moon
#define Rm (1737100.0)      /// радиус Луны
#define Lem (384467000.0)   /// расстояние между центрами Земли и Луны

#define G (6.6743015e-11)   /// гравитационная постоянная
#define DT (5)             /// шаг расчета по времени, в секундах
#define TICKER (5)          /// через сколько витков пишем репорты
#define TICKER_ROUND (1000) /// периодичность записи точек орбиты на последнем круге

#define M   (10.)           /// масса солнечного парусника
#define S   (100.)          /// площадь солнечного паруса
#define P   (9.0e-6)        /// давление солнечного ветра
#define A   ((S*P)/M)       /// ускорение парусника от солнечного ветра, действует по оси Х

/// #define     NOMOON          /// NOMOON - значит убираем Луну из задачи
#define     ROUNDS  (12000)   /// предельное общее количество витков всего полёта
int nmax = ROUNDS ;         /// ограничитель: летаем не более nmax витков

unsigned long long i;       /// количество тиков времени длительностью DT с начала полёта
int n = 0, zero_point ;     /// количество витков парусника вокруг центра координат, метка прохождения нуля витка
int     last_round = 0 ;    /// флаг последнего витка. Последний виток будет записываться в файл FILE *fo
int    stop_flight  = 0 ;   /// флаг, что настало время уходить на тест орбиты

FILE *fp, *fo;              /// файлы для записи репортов и для записи орбиты последнего витка

double  ae, am, axe, aye, axm, aym, /// текущие ускорения, и по осям от Земли и Луны
        phie, phim, re, rm, /// текущее угловое положение Земли и Луны и их радиусы орбит
        xe, ye, xm, ym,     /// координаты Земли и Луны
        vx, vy, v,          /// текущие скорости парусника по осям и суммарная
        x, y,               /// текущие координаты парусника по осям
        t,                  /// время с начала полёта
        r, phi,             /// радиус и угол phi парусника - в полярных координатах
        r0e, r0m ;          /// расстояние от парусника до центров Земли и Луны (для расчета силы тяжести)

double  phi_open, phi_close;/// углы phi открытия и закрытия паруса на каждом витке

double  r_max, r_min,       /// апогей и перигей парусника на витке
        v_max, v_min,       /// макс и мин скорость парусника на витке
        phi_max, phim_max ; /// углы phi парусника и phim Луны в момент прохождении парусником апогея витка

double  omegaem;            /// угловая скорость вращения пары Земля-Луна вокруг барицентра
double r_ans ;              /// пойдёт в ответ задачи о точности прихода на орбиту
double r_close = Lem, x_close, y_close ; /// координаты центра Луны на последнем витке в момент пролёта Капитана

double a ( double radius, double massa ){
/// ускорение парусника от силы притяжения к Земле или Луне         a = F / M(парусника)
    return  -( G * massa / (radius * radius ) ) ;   /// знак минус потому, что ускорение влево и вниз
}

int init ( ) {                      /// инициализация задачи
/// вычисляем параметры системы Земля-Луна
    double omega2 ;
    double u ;                      /// переносная скорость - для смены СО с центра Земли на барицентр
    omega2 = G * ( Me + Mm ) /  ( Lem * Lem * Lem ) ;
    omegaem = sqrt ( omega2 );      /// угловая скорость Земли и Луны относительно барицентра

#ifdef NOMOON                               /// не будем переходить в СО барицентра, если Луна не учитывается
    re = 0. ;
    rm = Lem ;
#else                                       /// переход в СО барицентра
    re = G * Mm  / ( omega2 * Lem * Lem ) ; /// расстояние от барицентра до центра Земли
    rm = G * Me  / ( omega2 * Lem * Lem ) ; /// расстояние от барицентра до центра Луны
#endif // NOMOON

/// посчитанный период обращения Луны, расстояния от барицентра до ц.Земли и ц.Луны
  printf ( "T=%.3lf days, re=%.3lf km, rm=%.3lf km\n", (2.*M_PI/omegaem )/(60.*60.*24.), re/1.e3, rm/1.e3 );

/// переходим в СО барицентра и устанавливаем начальные координаты
/// парусника, Земли, Луны и скорость парусника
const double x0 = 42174033.,    /// х-координата и скорость ракеты в момент прохождения
             v0 = 3074. ;       /// нулевой точки на ГСО (из первой задачи)

    x = x0 - re ;               /// новые координаты парусника
    y = 0.001 ;                 /// 1 миллиметр - чтобы не сработал флаг нулевой точки
    r = sqrt ( x*x + y*y ) ;    /// и в полярных координатах
    phi = atan2 ( y, x ) ;

    u = omegaem * re ;          /// линейная скорость ц.Земли относительно барицентра - это ПЕРЕНОСНАЯ
    vy = v = v0 - u ;           /// новая начальная скорость парусника
    vx = 0. ;

    phim = 0. ;                 /// стартовая фаза Луны: запускаем Луну с нулевого угла
    xm = rm * cos ( phim ) ;    /// начальные прямоугольные координаты Луны
    ym = rm * sin ( phim ) ;

    phie = phim + M_PI ;        /// Земля всегда находится в противоположной фазе от Луны
    xe = re * cos ( phie ) ;    /// на старте Земля будет на угле phie = 180 градусов.
    ye = re * sin ( phie ) ;    /// Начальные прямоугольные координаты Земли

/// углы phi, на которых парус будет открываться и закрываться на первом витке
/// Подобраны для точного выхода на апогей 384,467 км, если считать без учёта Луны
    phi_open =  -135. * M_PI / 180. ;
    phi_close = -45. * M_PI / 180. ;
    return 0 ;
}                               ///  инициализация закончена


int report ( ) {
/// В репорт пишем: номер витка;
/// апогей и перигей в тыс км; скорость в перигее и в апогее; угол апогея парусника и Луны; время полёта В ДНЯХ;
/// координаты Земли и Луны в момент прохождения парусником апогея
    static char format[] =
    "%5d; %7.3lf; %7.3lf; %8.2lf; %8.2lf; %7.1lf; %7.1lf; %7.1lf; %7.3lf; %7.3lf; %10.3lf; %10.3lf\n";
    fprintf ( fp, format, n, r_max/1.0e6, r_min/1.0e6, v_max, v_min, phi_max*180/M_PI,
             phim_max*180./M_PI, t/(60.*60.*24.),
             re*cos(phim_max+M_PI)/1.e6, re * sin ( phim_max+M_PI )/1.e6,
             rm*cos(phim_max)/1.e6, rm * sin ( phim_max )/1.e6 );
     printf (     format, n, r_max/1.0e6, r_min/1.0e6, v_max, v_min, phi_max*180/M_PI,
             phim_max*180./M_PI, t/(60.*60.*24.),
             re * cos(phim_max+M_PI)/1.e6, re * sin ( phim_max+M_PI )/1.e6,
             rm * cos(phim_max)/1.e6, rm * sin ( phim_max )/1.e6 );
    return 0 ;
}


int main ( ) {
    fp = fopen ( "2.csv" , "w" ) ;         /// сюда пишем репорты
    assert ( fp ) ;
int ticker = TICKER ;                       /// периодичность записи репортов, в витках
   fo = fopen ("orbit.csv" , "w" ) ;       /// сюда пишем траекторию последнего витка
   assert ( fo ) ;

    init ( );                               /// инициализируем
    zero_point = 0 ;                        /// флаг: 0 - на этом витке через нулевую точку ещё не пролетал
                                            ///       1 - на этом витке уже пролетал
    n = 0 ;                                 /// количество сделанных витков
    r_min = r_max = r ;                     /// начальная форма эллипса
    v_min = v_max = v ;

#ifdef NOMOON
    printf ( "NOMOON\n" ) ;
    nmax = 700 ;
#else
    printf ( "MOON\n" );
    nmax = ROUNDS ;
#endif // NOMOON


    fprintf ( fp, "round; Apogee;   Perigee; v_max;    v_min;     phi_max;phiM_max; days;     xe;      ye;         xm;         ym\n");
     printf (     "round; Apogee;   Perigee; v_max;    v_min;     phi_max;phiM_max; days;     xe;      ye;         xm;         ym\n");


    for ( i = 0L ; ; i++ ) {                /// полетели !
        double dx, dy, phiphi,  cos_phi, sin_phi;      /// временные переменные

        r = sqrt ( x*x + y*y );             /// полярные координаты парусника
        phi = atan2 ( y, x );

        dx = x - xe ;                       /// расстояние от парусника до Земли по осям
        dy = y - ye ;
        r0e = sqrt ( dx*dx + dy*dy ) ;      /// расстояние от парусника до Земли по прямой
        phiphi = atan2 ( dy , dx ) ;        /// угол между осью Х и направлением от парусника на Землю
        ae = a ( r0e , Me ) ;               /// ускорение парусника от Земли
        axe = ae * cos ( phiphi ) ;         /// проекции ускорения на оси
        aye = ae * sin ( phiphi ) ;

#ifdef NOMOON
        am = axm = aym = 0. ;               /// выключаем силу тяжести от Луны, если её нет
#else
        dx = x - xm ;                       /// расстояние от парусника до Луны по осям
        dy = y - ym ;
        r0m = sqrt ( dx*dx + dy*dy ) ;      /// расстояние от парусника до Луны по прямой
        phiphi = atan2 ( dy , dx ) ;        /// угол между осью Х и направлением от парусника на Луну
        am = a ( r0m , Mm ) ;               /// ускорение парусника от Луны
        axm = am * cos ( phiphi ) ;         /// проекции ускорения на оси
        aym = am * sin ( phiphi ) ;
#endif // NOMOON

        if ( phi >= phi_open && phi <= phi_close )
            vx += ( axe + axm + A ) * DT ;      /// если парус открыт, то ускорение А учитываем
        else
            vx += ( axe + axm ) * DT ;          /// если парус закрыт, то ускорение А не учитываем
        vy += ( aye + aym ) * DT ;              /// по оси Y солнечный ветер не давит
        v = sqrt ( vx*vx + vy*vy ) ;
        x += vx * DT ;                          /// пересчитываем координаты парусника
        y += vy * DT ;

        phie += omegaem * DT ;                  /// новые координаты Земли и Луны полярные
        phim += omegaem * DT ;
        if ( phie > M_PI ) phie -= 2. * M_PI ;  /// поддерживаем их в интервале от -180 до +180 градусов
        if ( phim > M_PI ) phim -= 2. * M_PI ;

        cos_phi = cos ( phie ) ;                /// немного экономлю на вызове синуса и косинуса,
        sin_phi = sin ( phie ) ;                /// т.к. Земля и Луна всегда находятся на противоположных углах
        xe = re * cos_phi ;
        ye = re * sin_phi  ;
        xm = rm * (-cos_phi) ;                  /// новые координаты Земли и Луны
        ym = rm * (-sin_phi) ;                  /// знаки синуса и косинуса переворачиваю

        if ( r > r_max ) {                      /// запоминаем место и величину апогея, потом запишем в репорт
                phi_max = phi ;
                r_max = r ;
                phim_max = phim ;               /// на каком угле находится Луна, когда парусник в апогее
        }
        r_min = min ( r_min, r ) ;              /// запоминаем величину перигея
        v_max = max ( v_max , v ) ;             /// и макс и мин скорости на витке
        v_min = min ( v_min , v ) ;

        if ( y < 0. ) zero_point = 0 ;  /// при полёте в нижней полуплоскости обнуляем флаг прохождения нулевой точки (х=+хmax, y=0)
        else                            /// проверяем прохождение нулевой точки
            if ( zero_point == 0 ) {    /// это прохождение нулевой точки
                if ( n % ticker == 0 ) report ( ) ; /// Пишем в репорт максимальные параметры витка
                zero_point = 1 ;        /// на этом витке нулевая точка пройдена, ставим флаг

#ifdef NOMOON
                if ( n < 497 || r_max < (Lem - 2825037) ) {         /// подобрано упреждение
                            phi_open =  -132.99 * M_PI / 180. ;       /// просто подобрано
                            phi_close = -47. * M_PI / 180. ;
                }
                else {
                            phi_open =  phi_close = 0. ;   /// ложимся в дрейф
                }

#else   /// АЛГОРИТМ УПРАВЛЕНИЯ ПАРУСОМ
///  Если достигнута орбита 250 х 150 тыс км, то ложимся в дрейф на тест орбиты
///  Первые 500 витков от начала полёта даём начальный разгон, затем такая логика:
///  Если фи снизу, то разгоняемся, поднимаем перигей.
///  Если фи сверху, и перигей позволяет, то разгоняемся, поднимаем апогей.
///  Иначе (то есть если фи не входит ни в верхний, ни в нижний сектор), то дрейфуем.
///  Последние 1000 витков дрейфуем в любом случае, для тестирования стабильности получившейся орбиты
///  Но за 570 витков до окончания тестового дрейфа захотелось приподнять орбиту поближе к Луне -
///  Закончилось неудачно, пришлось на 1535 витке нажимать на красную кнопку, записывать последний виток и завершать

                if ( n == 1534 ) nmax = 1535 ;            /// красная кнопка - аварийное завершение полёта на 1535 витке

                if ( r_max > 250.0e6 && r_min > 150.0e6 && stop_flight == 0 ) {
                        nmax = n + 1000 ;  /// тестовый дрейф на 1000 витков, и ставим флаг конца полёта
                        printf ("ORBIT TEST, nmax = %d\n" , nmax );
                        stop_flight = 1 ;
                } else

                if ( n < 500 ) {                                /// первые 500 витков - для разгона
                            phi_open =  -125. * M_PI / 180. ;   /// даём побольше сектор открытия паруса
                            phi_close = -35. * M_PI / 180. ;    /// от -125 до -35 градусов
                }
                else if ( n < nmax - 800 ) {        /// если осталось больше 800 витков до конца полёта, то рулим парусом так:
                            if ( phi_max > -110. * M_PI / 180. &&  /// если апогей снизу, то пытаемся округлить орбиту
                                 phi_max < -70. * M_PI / 180. )
                                 {
                                    phi_open =  -97. * M_PI / 180. ; /// парус открываем немножко
                                    phi_close = -83. * M_PI / 180. ; /// больше нельзя, иначе ось эллипса орбиты сразу резко разворачивает
                                 }
                            else if ( phi_max > 70. * M_PI / 180. && /// если апогей сверху,
                                    /// а также перигей не меньше 20 тыс км (запас от Земли, чтобы не врезаться),
                                    /// а также апогей не больше 300 тыс км (иначе эллипс внезапно резко удлинняется, не знаю почему)
                                 phi_max < 110. * M_PI / 180. && r_min > 20.0e6 && r_max < 300.0e6 )
                                {     /// парус открываем на прямой угол - так пытаемся поднять апогей
                                    phi_open =  -135. * M_PI / 180. ;
                                    phi_close = -45. * M_PI / 180. ;
                                 }
                            else {                                  /// если апогей не попадает ни в верхний, ни в нижний сектор, то
                                    phi_open = phi_close = 0.  ;    /// убираем парус и дрейфуем, ждём пока Луна не повернёт ось орбиты,
                                                                    /// а если никогда не повернёт (но такого не бывает), то сработает ограничитель nmax
                                 }
                }
                else {     /// последние 1000 витков - дрейф для тестирования стабильности орбиты

                        if ( n >= nmax - 570 && n <= nmax - 565 && phi_max > 70.*M_PI/180. && phi_max < 110.*M_PI/180.) {
                            printf ("BOOST at round %d\n" , n ) ;
                            /// в течение тестового дрейфа попытка немного поднять апогей - утянуло за орбиту Луны
                            phi_open =  -95. * M_PI / 180. ;
                            phi_close = -85. * M_PI / 180. ;
                        }
                        else
                             phi_open = phi_close = 0.  ;
                }
/// конец алгоритма управления парусом
#endif // NOMOON

                r_ans = r_max ;         /// r_ans - пойдёт в ответ как достинутый апогей
                r_max = 0. ;            /// обнуляем максимальные параметры для следующего витка
                r_min = Lem * 1000. ;
                phi_max = phim_max = -1000. ;
                v_max = 0. ;
                v_min = 9999.99 ;
                n++ ;                               /// счётчик витков
                if ( last_round ) break ;           /// после последнего витка обрываем цикл
                if ( n >= nmax ) last_round = 1 ;   /// начинаем последний виток, на нём будем записывать орбиту в FILE *fo
            }    /// конец обработки прохождения нулевой точки

        t += DT ;

/// запись координат орбиты последнего витка с периодичностью TICKER_ROUND
        if ( last_round && ( i % TICKER_ROUND == 0 ))
            fprintf ( fo , "%.3lf;%.3lf\n" , x/1.e6, y/1.e6 ) ; /// координаты в тысячах км

/// запомним координаты центра Луны в момент наибольшего сближения на последнем витке
        if ( last_round && fabs ( r - rm ) < r_close ) {
                r_close = fabs ( r - rm ) ;
                x_close = xm ; y_close = ym;
        }


    }  /// конец цикла, делаем следующий шаг DT

    fclose ( fp ) ;

    fprintf ( fo , "%lf;%lf\n" , x_close  / 1.0e6, y_close / 1.0e6 ) ;  /// допишем в orbit.csv координаты ц.Луны в момент пролёта
    fclose ( fo ) ;

/// Выводим на экран время полёта (витков и дней) и точность достижения орбиты Луны (километров)
    printf ( "\nRounds done = %d\nFlight time = %.0lf days\n(Apogee - Moon orbit) = %.0lf km\n",
                            n,    t / (60.*60.*24.) ,       ( r_ans - rm ) / 1000. ) ;
    return 0 ;
}
